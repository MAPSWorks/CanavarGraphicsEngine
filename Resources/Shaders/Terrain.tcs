#version 410 core
// This code is taken from https://github.com/fede-vaccaro/TerrainEngine-OpenGL and adopted.
// Define the number of CPs in the output patch
layout (vertices = 3) out;

uniform vec3 camera_position;
uniform float tessellation_multiplier;
uniform vec3 seed;
uniform int octaves;
uniform float amplitude;
uniform float freq;
uniform float power;

in vec3 cs_position[];
in vec3 cs_normal[];
in vec2 cs_texture_coord[];

out vec3 tes_position[];
out vec3 tes_normal[];
out vec2 tes_texture_coord[];

// Dummy random
float random2d(vec2 st)
{
     return fract(sin(dot(st.xy, vec2(12.9898, 78.233) + seed.xy)) * 43758.5453123);
}

// Cosine interpolation
float interpolate(float a, float b, float x)
{
    float ft = x * 3.14159265f;
    float f = (1 - cos(ft)) * 0.5;
    return  a * (1 - f) + b * f;
}

float interpolated_noise(float x, float y)
{
    int integer_x = int(floor(x));
    float fractional_x = fract(x);
    int integer_y = int(floor(y));
    float fractional_y = fract(y);
    vec2 random_input = vec2(integer_x, integer_y);
    float a = random2d(random_input);
    float b = random2d(random_input + vec2(1.0, 0.0));
    float c = random2d(random_input + vec2(0.0, 1.0));
    float d = random2d(random_input + vec2(1.0, 1.0));

    vec2 w = vec2(fractional_x, fractional_y);

    // We can use cubic interpolation here
    w = w*w*w*(10.0 + w * (-15.0 + 6.0*w));

    float k0 = a,
    k1 = b - a,
    k2 = c - a,
    k3 = d - c - b + a;

    return k0 + k1*w.x + k2*w.y + k3*w.x*w.y;
}

float perlin(float x, float y)
{
    float persistence = 0.5;
    float total = 0;
    float frequency = 0.005 * freq;
    float ampl = amplitude;

    for (int i = 0; i < octaves; i++)
    {
        frequency *= 2.;
        ampl *= persistence;
        total += interpolated_noise(x * frequency, y * frequency) * ampl;
    }

    return pow(total, power);
}

const mat2 m = mat2(0.8,-0.6,0.6,0.8);

float perlin(vec2 st)
{
    float persistence = 0.5;
    float total = 0.0;
    float frequency = 0.005 * freq;
    float ampl = amplitude;
    for (int i = 0; i < octaves; ++i)
    {
        frequency *= 2.0;
        ampl *= persistence;
        vec2 v = frequency*m*st;
        total += interpolated_noise(v.x,v.y) * ampl;
    }

    return pow(total, power);
}

float get_tessellation_level(float distance0, float distance1)
{
    float average_distance = (distance0 + distance1) / 2.0;

    if (average_distance <= 35.0 * 10.0)
    {
        return 60.0;
    }
    if (average_distance <= 70.0 * 10.0)
    {
        return 30.0;
    }
    else if (average_distance <= 300.0 * 10.0)
    {
        return 10.0;

    }else if(average_distance <= 1200.0 * 10.0)
    {
        return 2.5;
    }
    else if (average_distance <= 3000.0 * 10.0)
    {
        return 1.0;
    }
    else
    {
        return 1.0;
    }
}

void main()
{
    // Set the control points of the output patch
    tes_position[gl_InvocationID] = cs_position[gl_InvocationID];
    tes_normal[gl_InvocationID]   = cs_normal[gl_InvocationID];
    tes_texture_coord[gl_InvocationID] = cs_texture_coord[gl_InvocationID];

    // Calculate the distance from the camera to the three control points
    vec3 world_pos_1 = vec3(tes_position[0].x, perlin(tes_position[0].xz), tes_position[0].z);
    vec3 world_pos_2 = vec3(tes_position[1].x, perlin(tes_position[1].xz), tes_position[1].z);
    vec3 world_pos_3 = vec3(tes_position[2].x, perlin(tes_position[2].xz), tes_position[2].z);

    float d0 = distance(camera_position, world_pos_1);
    float d1 = distance(camera_position, world_pos_1);
    float d2 = distance(camera_position, world_pos_1);

    // Calculate the tessellation levels
    gl_TessLevelOuter[0] = tessellation_multiplier * get_tessellation_level(d1, d2);
    gl_TessLevelOuter[1] = tessellation_multiplier * get_tessellation_level(d2, d0);
    gl_TessLevelOuter[2] = tessellation_multiplier * get_tessellation_level(d0, d1);
    gl_TessLevelInner[0] = gl_TessLevelOuter[2];
}
